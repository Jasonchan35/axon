// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Text;
namespace axc {

public class Parser {
	
	Token		token;
	LexerPos	pos;

	char		ch = '\0';

	public void setPos( Token token, LexerPos pos ) {
		this.token = token;
		this.pos = pos;
		nextToken();
	}
	
	public	void skipNewLines() {
		while( token.type == TokenType.newline ) {
			nextToken();
		}
	}

	public	void trimSeperators() {
		for(;;) {
			nextChar();
			if( ! chIsSeperator ) break;
		}
	}

	public void nextToken() {
		_getToken();

		Log.Info( token.ToString() );
	}

	void _getToken() {
		token.type = TokenType.unknown;
		token.str  = "";

		trimSeperators();
		token.pos = pos;

		switch( ch ) {
			case '\0': {
				token.Set( TokenType.EOF, "<EOF>" );
			}break;

			case '\n': {
				nextChar();
				token.Set( TokenType.newline, "<newline>" );
			}break;

			case '[': { nextChar(); token.Set( TokenType.squareBracketOpen, 	"[" );	return; };
			case ']': { nextChar(); token.Set( TokenType.squareBracketClose,	"]" );	return; };

			case '(': { nextChar(); token.Set( TokenType.roundBracketOpen, 		"(" );	return; };
			case ')': { nextChar(); token.Set( TokenType.roundBracketClose,		")" );	return; };

			case '{': { nextChar(); token.Set( TokenType.curlyBracketOpen, 		"{" );	return; };
			case '}': { nextChar(); token.Set( TokenType.curlyBracketClose,		"}" );	return; };
///---------
			case ';': { nextChar(); token.Set( TokenType.semiColon,				";" );	return; };
			case ',': { nextChar(); token.Set( TokenType.comma,					"," );	return; };
			case '`': { nextChar(); token.Set( TokenType.backMark,				"`" );	return; };
			case '$': { nextChar(); token.Set( TokenType.dollar,				"$" );	return; };
			case '#': { nextChar(); token.Set( TokenType.hash,					"#" );	return; };
			case '@': { nextChar(); token.Set( TokenType.at,					"@" );	return; };
			case '\\':{ nextChar(); token.Set( TokenType.backSlash,				"\\");	return; };

			case '?': {
				nextChar();
				if( ch == '.' ) { 
					nextChar();
					token.Set( TokenType.questionDot, "?." );
					return;
				}

				token.Set( TokenType.question, "?" );
				return;
			}	

			case '=': {
				nextChar();
				if( ch == '=' ) {
					nextChar();
					if( ch == '=' ) { nextChar();	token.Set( TokenType.equals3, "===" ); return; }				
				
					token.Set( TokenType.equals, "==" );
					return;
				}

				token.Set( TokenType.assign, "=" );
				return;
			};
				
			case '!': {
				nextChar();
				if( ch == '.' ) { 
					nextChar();
					token.Set( TokenType.exclamationDot, "!." );
					return;
				}
				if( ch == '=' ) {
					nextChar();
					if( ch == '=' ) {
						nextChar();
						token.Set( TokenType.notEquals3, "!==" );
						return;
					}
					token.Set( TokenType.notEquals, "!=" );
					return;
				}
				token.Set( TokenType.exclamation, "!" );
				return;
			};
				
			case '<': {
				nextChar();
				if( ch == '<' ) { nextToken(); token.Set( TokenType.less2, 			"<<" ); return; }
				if( ch == '>' ) { nextToken(); token.Set( TokenType.lessGreater, 	"<>" ); return; }
				if( ch == '=' ) { nextToken(); token.Set( TokenType.lessEquals, 	"<=" ); return; }
				token.Set( TokenType.less, "<" );
				return;
			};
				
			case '>': {
				nextChar();
				if( ch == '>' ) { nextToken(); token.Set( TokenType.greater2, 		">>" ); return; }
				if( ch == '=' ) { nextToken(); token.Set( TokenType.greaterEquals, 	">=" ); return; }
				token.Set( TokenType.greater, ">" );
				return;
			};
				
			case '+': {
				nextChar();
				if( ch == '+' ) { nextToken(); token.Set( TokenType.add2, 			"++" ); return; }
				if( ch == '=' ) { nextToken(); token.Set( TokenType.addAssign, 		"+=" ); return; }
				token.Set( TokenType.add, "+" );
				return;
			};
				
			case '-': {
				nextChar();
				if( ch == '-' ) { nextToken(); token.Set( TokenType.sub2, 			"--" ); return; }
				if( ch == '=' ) { nextToken(); token.Set( TokenType.subAssign, 		"-=" ); return; }
				token.Set( TokenType.sub, "-" );
				return;
			};
				
			case '*': {
				nextChar();
				if( ch == '*' ) { nextToken(); token.Set( TokenType.mul2, 			"**" ); return; }
				if( ch == '=' ) { nextToken(); token.Set( TokenType.mulAssign, 		"*=" ); return; }
				token.Set( TokenType.mul, "*" );
				return;
			};
				
			case '%': {
				nextChar();
				if( ch == '%' ) { nextToken(); token.Set( TokenType.mod2, 			"%%" ); return; }
				if( ch == '=' ) { nextToken(); token.Set( TokenType.modAssign, 		"%=" ); return; }
				token.Set( TokenType.mod, "%" );
				return;
			};
				
			case ':': {
				nextChar();
				if( ch == ':' ) { nextToken(); token.Set( TokenType.colon2, 		"::" ); return; }
				if( ch == '=' ) { nextToken(); token.Set( TokenType.colonAssign, 	":=" ); return; }
				token.Set( TokenType.colon, "%" );
				return;
			};

			case '/': {
				//			ax_TempString	tmp;
				nextChar();
				if( ch == '/' ) { //skip comment line
					nextChar();
					//				tmp.append( ax_txt("//") );
					
					for( ; ch != '\0'; nextChar() ) {
						if( ch == '\n' ) break;
					}

					token.Set( TokenType.comment, "<comment line>" );

					nextChar();
					return;
				}
				
				if( ch == '*' ) { //skip comment block
					nextChar();

					int level = 1;
					for( ;ch != '\0'; nextChar() ) {
						if( ch == '*' ) {
							nextChar();
							if( ch == '/' ) {
								level--;

								if( level == 0 ) break;
								continue;
							}
						}
						
						if( ch == '/' ) {
							nextChar();
							if( ch == '*' ) {
								level++;

								if( level > 256 ) Log.Error( pos, "excess comment block level limit" );
								continue;
							}
						}
						
						//					tmp.append(c);
					}
					nextChar();

					token.Set( TokenType.comment, "<comment>");
					return;
				}
				
				if( ch == '=' ) { 
					nextChar();
					token.Set( TokenType.divAssign, "/=" ); 
					return;
				}

				token.Set ( TokenType.div, "/" );
				return;
			}
			
			//String
			case '\"': {
				var sb = new StringBuilder();
				nextChar();
				for( ; ch!='\0'; nextChar() ) {
					if( ch == '\\' ) {
						nextChar();
						if( ch == '\0'  ) {
							Log.Error( pos, "Unexpected end of string");
						}
						
							 if( ch == '\0') { sb.Append('\0'); }
						else if( ch == '"' ) { sb.Append('\"'); }
						else if( ch == '\'') { sb.Append('\''); }
						else if( ch == '\\') { sb.Append('\\'); }
						
						else if( ch == 'n' ) { sb.Append('\n'); }	// newline
						else if( ch == 't' ) { sb.Append('\t'); }	// tab
						else if( ch == 'r' ) { sb.Append('\r'); }	// carriage return
						
						else if( ch == 'a' ) { sb.Append('\a'); }	// audible bell
						else if( ch == 'b' ) { sb.Append('\b'); }	// backspace
						else if( ch == 'f' ) { sb.Append('\f'); }	// form feed - new page
						else if( ch == 'u' ) {
							int wc = 0;
							for( int i=0; i<4; i++ ) {
								nextChar();
								if( ch >= '0' && ch <= '9' ) {
									wc <<= 4;	wc |= ch -'0';
								}else if( ch >= 'A' && ch <= 'F' ) {
									wc <<= 4;	wc |= ch -'A' + 10;
								}else if( ch >= 'a' && ch <= 'f' ) {
									wc <<= 4;	wc |= ch -'a';
								}else{
									Log.Error( pos, "unicode hex expected [0-9,A-F]" );
								}
							}
							sb.Append( wc );
						
						}else {
							Log.Error( pos, "unknown string literal escape sequence ["+ch+"]" );
						}
						continue;
					}
					
					if( ch == '\"' ) break;
					sb.Append(ch);
				}
				nextChar();
				token.Set(TokenType.stringLiteral, sb.ToString() );
				return;
			};
		}

//		if( charIsDigit() ) _getToken_number();

		if( chIsAlpha || chIsDigit ) {
			var sb = new StringBuilder();
			for( ; ch != '\0'; nextChar() ) {
				if( chIsAlpha || chIsDigit || ch == '_' ) {
					sb.Append(ch);
				}else{
					break;
				}				
			}

			token.Set( TokenType.identifier, sb.ToString() );
			return;
		}

		Log.Error("unknown character "+ (int)ch + " [" + ch + "] " + pos.line + ":" + pos.col );
	}

	bool chIsDigit 	{ get{ return ch >= '0' && ch <='9'; } }
	bool chIsAlpha 	{ 
		get{ 
			if( ch >= 'a' && ch <= 'z' ) return true;
			if( ch >= 'A' && ch <= 'Z' ) return true;
			return false;
		}
	}

	bool chIsSeperator { get{ return ch == ' ' || ch == '\t' || ch == '\r'; } }

	void nextChar() {
		if( pos.filePos < 0 || pos.filePos >= pos.sourceFile.sourceCode.Length ) {
			ch = '\0';
			return;
		}

		if( ch == '\n' ) {
			pos.line++;
			pos.col = 1;
		}else{
			pos.col++;
		}

		ch = pos.sourceFile.sourceCode[pos.filePos];
		pos.filePos++;		
	}

}

}

