<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0042)http://www.hboehm.info/gc/gcinterface.html -->
<html lang="en-us"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>Garbage Collector Interface</title>
</head>
<body>
<h1>C Interface</h1>
On many platforms, a single-threaded garbage collector library can be built
to act as a plug-in malloc replacement.
(Build with <tt>-DREDIRECT_MALLOC=GC_malloc -DIGNORE_FREE</tt>.)
This is often the best way to deal with third-party libraries
which leak or prematurely free objects.  <tt>-DREDIRECT_MALLOC</tt> is intended
primarily as an easy way to adapt old code, not for new development.
<p>
New code should use the interface discussed below.
</p><p>
Code must be linked against the GC library.  On most UNIX platforms,
depending on how the collector is built, this will be <tt>gc.a</tt>
or <tt>libgc.{a,so}</tt>.
</p><p>
The following describes the standard C interface to the garbage collector.
It is not a complete definition of the interface.  It describes only the
most commonly used functionality, approximately in decreasing order of
frequency of use.
The full interface is described in
<a href="http://www.hboehm.info/gc/gc_source/gch.txt">gc.h</a>
or <tt>gc.h</tt> in the distribution.
</p><p>
Clients should include <tt>gc.h</tt>.
</p><p>
In the case of multithreaded code,
<tt>gc.h</tt> should be included after the threads header file, and
after defining the appropriate <tt>GC_</tt><i>XXXX</i><tt>_THREADS</tt> macro.
(For 6.2alpha4 and later, simply defining <tt>GC_THREADS</tt> should suffice.)
The header file <tt>gc.h</tt> must be included
in files that use either GC or threads primitives, since threads primitives
will be redefined to cooperate with the GC on many platforms.
</p><p>
Thread users should also be aware that on many platforms objects reachable
only from thread-local variables may be prematurely reclaimed.
Thus objects pointed to by thread-local variables should also be pointed to
by a globally visible data structure.  (This is viewed as a bug, but as
one that is exceedingly hard to fix without some libc hooks.)
</p><dl>
<dt> <b>void * GC_MALLOC(size_t <i>nbytes</i>)</b>
</dt><dd>
Allocates and clears <i>nbytes</i> of storage.
Requires (amortized) time proportional to <i>nbytes</i>.
The resulting object will be automatically deallocated when unreferenced.
References from objects allocated with the system malloc are usually not
considered by the collector.  (See <tt>GC_MALLOC_UNCOLLECTABLE</tt>, however.)
<tt>GC_MALLOC</tt> is a macro which invokes <tt>GC_malloc</tt> by default or,
if <tt>GC_DEBUG</tt>
is defined before <tt>gc.h</tt> is included, a debugging version that checks
occasionally for overwrite errors, and the like.
</dd><dt> <b>void * GC_MALLOC_ATOMIC(size_t <i>nbytes</i>)</b>
</dt><dd>
Allocates <i>nbytes</i> of storage.
Requires (amortized) time proportional to <i>nbytes</i>.
The resulting object will be automatically deallocated when unreferenced.
The client promises that the resulting object will never contain any pointers.
The memory is not cleared.
This is the preferred way to allocate strings, floating point arrays,
bitmaps, etc.
More precise information about pointer locations can be communicated to the
collector using the interface in
<a href="http://www.hboehm.info/gc/gc_source/gc_typedh.txt">gc_typed.h</a> in the distribution.
</dd><dt> <b>void * GC_MALLOC_UNCOLLECTABLE(size_t <i>nbytes</i>)</b>
</dt><dd>
Identical to <tt>GC_MALLOC</tt>,
except that the resulting object is not automatically
deallocated.  Unlike the system-provided malloc, the collector does
scan the object for pointers to garbage-collectable memory, even if the
block itself does not appear to be reachable.  (Objects allocated in this way
are effectively treated as roots by the collector.)
</dd><dt> <b> void * GC_REALLOC(void *<i>old</i>, size_t <i>new_size</i>) </b>
</dt><dd>
Allocate a new object of the indicated size and copy (a prefix of) the
old object into the new object.  The old object is reused in place if
convenient.  If the original object was allocated with
<tt>GC_MALLOC_ATOMIC</tt>,
the new object is subject to the same constraints.  If it was allocated
as an uncollectable object, then the new object is uncollectable, and
the old object (if different) is deallocated.
</dd><dt> <b> void GC_FREE(void *<i>dead</i>) </b>
</dt><dd>
Explicitly deallocate an object.  Typically not useful for small
collectable objects.
</dd><dt> <b> void * GC_MALLOC_IGNORE_OFF_PAGE(size_t <i>nbytes</i>) </b>
</dt><dd>
</dd><dt> <b> void * GC_MALLOC_ATOMIC_IGNORE_OFF_PAGE(size_t <i>nbytes</i>) </b>
</dt><dd>
Analogous to <tt>GC_MALLOC</tt> and <tt>GC_MALLOC_ATOMIC</tt>,
except that the client
guarantees that as long
as the resulting object is of use, a pointer is maintained to someplace
inside the first 512 bytes of the object.  This pointer should be declared
volatile to avoid interference from compiler optimizations.
(Other nonvolatile pointers to the object may exist as well.)
This is the
preferred way to allocate objects that are likely to be &gt; 100KBytes in size.
It greatly reduces the risk that such objects will be accidentally retained
when they are no longer needed.  Thus space usage may be significantly reduced.
</dd><dt> <b> void GC_INIT(void) </b>
</dt><dd>
On some platforms, it is necessary to invoke this
<i>from the main executable, not from a dynamic library,</i> before
the initial invocation of a GC routine.  It is recommended that this be done
in portable code, though we try to ensure that it expands to a no-op
on as many platforms as possible.  In GC 7.0, it was required if
thread-local allocation is enabled in the collector build, and <tt>malloc</tt>
is not redirected to <tt>GC_malloc</tt>.
</dd><dt> <b> void GC_gcollect(void) </b>
</dt><dd>
Explicitly force a garbage collection.
</dd><dt> <b> void GC_enable_incremental(void) </b>
</dt><dd>
Cause the garbage collector to perform a small amount of work
every few invocations of <tt>GC_MALLOC</tt> or the like, instead of performing
an entire collection at once.  This is likely to increase total
running time.  It will improve response on a platform that either has
suitable support in the garbage collector (Linux and most Unix
versions, win32 if the collector was suitably built) or if "stubborn"
allocation is used (see
<a href="http://www.hboehm.info/gc/gc_source/gch.txt">gc.h</a>).
On many platforms this interacts poorly with system calls 
that write to the garbage collected heap.
</dd><dt> <b> GC_warn_proc GC_set_warn_proc(GC_warn_proc <i>p</i>) </b>
</dt><dd>
Replace the default procedure used by the collector to print warnings.
The collector
may otherwise write to sterr, most commonly because GC_malloc was used
in a situation in which GC_malloc_ignore_off_page would have been more
appropriate.  See <a href="http://www.hboehm.info/gc/gc_source/gch.txt">gc.h</a> for details.
</dd><dt> <b> void GC_REGISTER_FINALIZER(...) </b>
</dt><dd>
Register a function to be called when an object becomes inaccessible.
This is often useful as a backup method for releasing system resources
(<i>e.g.</i> closing files) when the object referencing them becomes
inaccessible.
It is not an acceptable method to perform actions that must be performed
in a timely fashion.
See <a href="http://www.hboehm.info/gc/gc_source/gch.txt">gc.h</a> for details of the interface.
See <a href="http://www.hboehm.info/gc/finalization.html">here</a> for a more detailed discussion
of the design.
<p>
Note that an object may become inaccessible before client code is done
operating on objects referenced by its fields.
Suitable synchronization is usually required.
See <a href="http://portal.acm.org/citation.cfm?doid=604131.604153">here</a>
or <a href="http://www.hpl.hp.com/techreports/2002/HPL-2002-335.html">here</a>
for details.
</p></dd></dl>
<p>
If you are concerned with multiprocessor performance and scalability,
you should consider enabling and using thread local allocation.
For GC versions before 7.0, use <i>e.g.</i>
<tt>GC_LOCAL_MALLOC</tt> and see <tt>gc_local_alloc.h</tt>;
for later versions enabling thread-local allocations when the collector
library is built changes the
implementation of <tt>GC_MALLOC</tt>, so the client doesn't need to
change.
</p><p>
If your platform
supports it, you should build the collector with parallel marking support
(<tt>-DPARALLEL_MARK</tt>, or <tt>--enable-parallel-mark</tt>).
</p><p>
If the collector is used in an environment in which pointer location
information for heap objects is easily available, this can be passed on
to the collector using the interfaces in either <tt>gc_typed.h</tt>
or <tt>gc_gcj.h</tt>.
</p><p>
The collector distribution also includes a <b>string package</b> that takes
advantage of the collector.  For details see
<a href="http://www.hboehm.info/gc/gc_source/cordh.txt">cord.h</a>

</p><h1>C++ Interface</h1>
The C++ interface is implemented as a thin layer on the C interface.
Unfortunately, this thin layer appears to be very sensitive to variations
in C++ implementations, particularly since it tries to replace the global
::new operator, something that appears to not be well-standardized.
Your platform may need minor adjustments in this layer (gc_cpp.cc, gc_cpp.h,
and possibly gc_allocator.h).  Such changes do not require understanding
of collector internals, though they may require a good understanding of
your platform.  (Patches enhancing portability are welcome.
But it's easy to break one platform by fixing another.)
<p>
Usage of the collector from C++ is also complicated by the fact that there
are many "standard" ways to allocate memory in C++.  The default ::new
operator, default malloc, and default STL allocators allocate memory
that is not garbage collected, and is not normally "traced" by the
collector.  This means that any pointers in memory allocated by these
default allocators will not be seen by the collector.  Garbage-collectable
memory referenced only by pointers stored in such default-allocated
objects is likely to be reclaimed prematurely by the collector.
</p><p>
It is the programmers responsibility to ensure that garbage-collectable
memory is referenced by pointers stored in one of
</p><ul>
<li> Program variables
</li><li> Garbage-collected objects
</li><li> Uncollected but "traceable" objects
</li></ul>
"Traceable" objects are not necessarily reclaimed by the collector,
but are scanned for pointers to collectable objects.
They are usually allocated by <tt>GC_MALLOC_UNCOLLECTABLE</tt>, as described
above, and through some interfaces described below.
<p>
(On most platforms, the collector may not trace correctly from in-flight
exception objects.  Thus objects thrown as exceptions should only
point to otherwise reachable memory.  This is another bug whose
proper repair requires platform hooks.)
</p><p>
The easiest way to ensure that collectable objects are properly referenced
is to allocate only collectable objects.  This requires that every
allocation go through one of the following interfaces, each one of
which replaces a standard C++ allocation mechanism.  Note that
this requires that all STL containers be explicitly instantiated with
<tt>gc_allocator</tt>.
</p><dl>
<dt> <b> STL allocators </b>
</dt><dd>
<p>
Recent versions of the collector include a hopefully standard-conforming
allocator implementation in <tt>gc_allocator.h</tt>.  It defines
</p><ul>
<li> <tt>traceable_allocator</tt>
</li><li> <tt>gc_allocator</tt>
</li></ul>
which may be used either directly to allocate memory or to instantiate
container templates. 
The former allocates uncollectable but traced memory.
The latter allocates garbage-collected memory.
<p>
These should work with any fully standard-conforming C++ compiler.
</p><p>
Users of the <a href="http://www.sgi.com/tech/stl">SGI extended STL</a>
or its derivatives (including most g++ versions)
may instead be able to include <tt>new_gc_alloc.h</tt> before including
STL header files.  This is increasingly discouraged.
(<tt>gc_alloc.h</tt> corresponds to now obsolete versions of the
SGI STL.)  This interface is no longer recommended, but it has existed
for much longer.
</p><p>
This defines SGI-style allocators
</p><ul>
<li> <tt>alloc</tt>
</li><li> <tt>single_client_alloc</tt>
</li><li> <tt>gc_alloc</tt>
</li><li> <tt>single_client_gc_alloc</tt>
</li></ul>
The first two allocate uncollectable but traced
memory, while the second two allocate collectable memory.
The <tt>single_client</tt> versions are not safe for concurrent access by
multiple threads, but are faster.
<p>
For an example, click <a href="http://www.hboehm.info/gc/gc_alloc_exC.txt">here</a>.
</p></dd><dt> <b> Class inheritance based interface for new-based allocation</b>
</dt><dd>
Users may include gc_cpp.h and then cause members of classes to
be allocated in garbage collectable memory by having those classes
inherit from class gc.
For details see <a href="http://www.hboehm.info/gc/gc_source/gc_cpph.txt">gc_cpp.h</a>.
<p>
Linking against libgccpp in addition to the gc library overrides
::new (and friends) to allocate traceable memory but uncollectable
memory, making it safe to refer to collectable objects from the resulting
memory.
</p></dd><dt> <b> C interface </b>
</dt><dd>
It is also possible to use the C interface from 
<a href="http://www.hboehm.info/gc/gc_source/gch.txt">gc.h</a> directly.
On platforms which use malloc to implement ::new, it should usually be possible
to use a version of the collector that has been compiled as a malloc
replacement.  It is also possible to replace ::new and other allocation
functions suitably, as is done by libgccpp.
<p>
Note that user-implemented small-block allocation often works poorly with
an underlying garbage-collected large block allocator, since the collector
has to view all objects accessible from the user's free list as reachable.
This is likely to cause problems if <tt>GC_MALLOC</tt>
is used with something like
the original HP version of STL.
This approach works well with the SGI versions of the STL only if the
<tt>malloc_alloc</tt> allocator is used.
</p></dd></dl>


</body></html>